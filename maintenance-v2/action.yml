name: Maintenance V2
description: Enable or disable maintenance for a service with centralized templates
inputs:
  # Required inputs
  environment:
    description: Name of the app environment
    required: true
  mode:
    description: Maintenance mode to implement, either enable or disable
    required: true
  
  # Azure authentication inputs
  azure-credentials:
    description: 'JSON string containing service principal credentials'
    required: false
    default: ''
  azure-client-id:
    description: Azure client ID when using OIDC
    required: false
    default: ''
  azure-subscription-id:
    description: Azure subscription ID when using OIDC
    required: false
    default: ''
  azure-tenant-id:
    description: Azure tenant ID when using OIDC
    required: false
    default: ''
  
  # Docker configuration
  docker-repository:
    description: Name of the maint app docker repository
    required: false
  github-token:
    description: GitHub token for repository access
    required: false
  
  # Customization inputs (all optional with sensible defaults)
  service-name:
    description: Human-readable service name for the maintenance page
    required: false
    default: 'This service'
  
  maintenance-message:
    description: Custom maintenance message to display to users
    required: false
    default: 'We are currently carrying out essential maintenance. Please try again later.'
  
  contact-email:
    description: Support contact email to display
    required: false
    default: ''
  
  estimated-return-time:
    description: Estimated time when service will be back (e.g., "15:00" or "3:00 PM")
    required: false
    default: ''
  
  status-page-url:
    description: URL to external status page for updates
    required: false
    default: ''
  
  template-ref:
    description: Branch/tag/commit of teacher-services-cloud repository to use
    required: false
    default: 'main'

runs:
  using: composite
  steps:
    - uses: azure/login@v2
      if: inputs.azure-credentials != ''
      with:
        creds: ${{ inputs.azure-credentials }}

    - uses: azure/login@v2
      if: inputs.azure-credentials == ''
      with:
        client-id: ${{ inputs.azure-client-id }}
        tenant-id: ${{ inputs.azure-tenant-id }}
        subscription-id: ${{ inputs.azure-subscription-id }}

    - name: Set ARM and kubelogin environment
      uses: DFE-Digital/github-actions/set-kubelogin-environment@master
      with:
        azure-credentials: ${{ inputs.azure-credentials }}
        azure-client-id: ${{ inputs.azure-client-id }}
        azure-tenant-id: ${{ inputs.azure-tenant-id }}
        azure-subscription-id: ${{ inputs.azure-subscription-id }}

    - name: Fetch and customize maintenance page templates
      if: inputs.mode == 'enable'
      shell: bash
      run: |
        echo "Fetching maintenance page templates from teacher-services-cloud..."
        echo "Current directory: $(pwd)"
        echo "GitHub workspace: ${{ github.workspace }}"
        
        # Create maintenance_page directory if it doesn't exist
        mkdir -p maintenance_page
        
        # Create temp directory for cloning
        TEMP_DIR=$(mktemp -d)
        echo "Temp directory: $TEMP_DIR"
        
        # Clone only the templates directory (sparse checkout)
        cd $TEMP_DIR
        git clone --filter=blob:none --sparse https://github.com/DFE-Digital/teacher-services-cloud.git
        cd teacher-services-cloud
        git sparse-checkout set templates/new_service/maintenance_page
        git checkout ${{ inputs.template-ref }}
        
        # Debug: Check what files we have
        echo "Files in template directory:"
        ls -la templates/new_service/maintenance_page/
        
        # Copy ONLY the necessary template files (Dockerfile, nginx.conf, html)
        # DO NOT touch existing manifests or scripts directories in the service repo
        cp templates/new_service/maintenance_page/Dockerfile ${{ github.workspace }}/maintenance_page/
        cp templates/new_service/maintenance_page/nginx.conf ${{ github.workspace }}/maintenance_page/
        
        # Remove existing html directory and copy fresh from template
        rm -rf ${{ github.workspace }}/maintenance_page/html
        cp -r templates/new_service/maintenance_page/html ${{ github.workspace }}/maintenance_page/
        
        # Copy the maintenance manifests templates (deployment and service only)
        # These go in manifests/maintenance/ directory
        mkdir -p ${{ github.workspace }}/maintenance_page/manifests/maintenance
        cp -r templates/new_service/maintenance_page/manifests/maintenance/* ${{ github.workspace }}/maintenance_page/manifests/maintenance/
        
        # Check if service has the required directories
        if [ ! -d "${{ github.workspace }}/maintenance_page/manifests/staging" ] && [ ! -d "${{ github.workspace }}/maintenance_page/manifests/production" ]; then
          echo "WARNING: No environment-specific manifests found in maintenance_page/manifests/"
          echo "Please ensure your repository contains:"
          echo "  - maintenance_page/manifests/staging/ (for staging environment)"
          echo "  - maintenance_page/manifests/production/ (for production environment)"
        fi
        
        if [ ! -d "${{ github.workspace }}/maintenance_page/scripts" ]; then
          echo "WARNING: No scripts directory found in maintenance_page/"
          echo "Using template scripts as fallback..."
          cp -r templates/new_service/maintenance_page/scripts ${{ github.workspace }}/maintenance_page/
        else
          echo "Using existing service-specific scripts from maintenance_page/scripts/"
        fi
        
        # Debug: Verify files were copied
        echo "Files in maintenance_page directory:"
        ls -la ${{ github.workspace }}/maintenance_page/
        
        # Clean up temp directory
        rm -rf $TEMP_DIR
        
        echo "Templates fetched successfully"
        
        # Apply customizations
        echo "Applying service customizations..."
        cd ${{ github.workspace }}
        
        # Replace service name placeholder
        sed -i "s/#SERVICE_PRETTY#/${{ inputs.service-name }}/g" maintenance_page/html/index.html
        
        # Replace maintenance message placeholder
        ESCAPED_MESSAGE=$(echo "${{ inputs.maintenance-message }}" | sed 's/[[\.*^$()+?{|]/\\&/g')
        sed -i "s/#MAINTENANCE_MESSAGE#/${ESCAPED_MESSAGE}/g" maintenance_page/html/index.html
        
        # Handle estimated return time
        if [[ -n "${{ inputs.estimated-return-time }}" ]]; then
          RETURN_HTML="<p class=\"govuk-body\">We expect the service to be available again at: <strong>${{ inputs.estimated-return-time }}</strong></p>"
          sed -i "s|#ESTIMATED_RETURN#|${RETURN_HTML}|g" maintenance_page/html/index.html
        else
          sed -i "s|#ESTIMATED_RETURN#||g" maintenance_page/html/index.html
        fi
        
        # Handle status page URL
        if [[ -n "${{ inputs.status-page-url }}" ]]; then
          STATUS_HTML="<p class=\"govuk-body\">For updates, please visit our <a href=\"${{ inputs.status-page-url }}\" class=\"govuk-link\">status page</a>.</p>"
          sed -i "s|#STATUS_PAGE#|${STATUS_HTML}|g" maintenance_page/html/index.html
        else
          sed -i "s|#STATUS_PAGE#||g" maintenance_page/html/index.html
        fi
        
        # Handle contact email
        if [[ -n "${{ inputs.contact-email }}" ]]; then
          CONTACT_HTML="<li>Email: <a class=\"govuk-link app-!-overflow-break-word govuk-footer__link\" href=\"mailto:${{ inputs.contact-email }}\">${{ inputs.contact-email }}</a></li>"
          CONTACT_HTML="${CONTACT_HTML}<li>We aim to respond within 5 working days, or one working day for more urgent queries</li>"
          sed -i "s|#CONTACT_INFO#|${CONTACT_HTML}|g" maintenance_page/html/index.html
        else
          # If no email provided, remove the entire Get help section
          sed -i '/<h2 class="govuk-heading-m">Get help<\/h2>/,/<\/ul>/c\' maintenance_page/html/index.html
        fi
        
        echo "Customizations applied successfully"
        
        # Also need to replace placeholders in the manifests
        # Get the service name from the docker repository (e.g., "teacher-success" from "ghcr.io/dfe-digital/teacher-success-maintenance")
        # First extract just the repo name, then get the service part
        REPO_NAME=$(echo "${{ inputs.docker-repository }}" | sed 's|.*/||')
        SERVICE_NAME=$(echo "$REPO_NAME" | sed 's/-maintenance$//')
        echo "Service name for manifests: $SERVICE_NAME"
        
        # Replace placeholders in deployment template (but keep #MAINTENANCE_IMAGE_TAG# for the script to replace)
        sed -i "s/#SERVICE_NAME#/${SERVICE_NAME}/g" maintenance_page/manifests/maintenance/deployment_maintenance.yml.tmpl
        sed -i "s|#DOCKER_REPOSITORY#|${{ inputs.docker-repository }}|g" maintenance_page/manifests/maintenance/deployment_maintenance.yml.tmpl
        
        # Replace placeholders in service manifest
        sed -i "s/#SERVICE_NAME#/${SERVICE_NAME}/g" maintenance_page/manifests/maintenance/service_maintenance.yml
        
        echo "Manifest placeholders replaced"

    - name: Build and push docker image
      if: inputs.mode == 'enable'
      id: build-image
      uses: DFE-Digital/github-actions/build-docker-image@master
      with:
        github-token: ${{ inputs.github-token }}
        dockerfile-path: maintenance_page/Dockerfile
        docker-repository: ${{ inputs.docker-repository }}
        context: maintenance_page

    # Note: We don't clean up maintenance_page directory here because:
    # 1. The scripts directory is needed by the Makefile for failover.sh
    # 2. The manifests directory might be needed for checking temp URLs
    # The directory will be cleaned up when the workflow ends anyway

    - name: Enable maintenance mode
      if: inputs.mode == 'enable'
      shell: bash
      run: make ci ${{ inputs.environment }} maintenance-fail-over
      env:
        MAINTENANCE_IMAGE_TAG: ${{steps.build-image.outputs.tag}}

    - name: Disable maintenance mode
      if: inputs.mode == 'disable'
      shell: bash
      run: make ci ${{ inputs.environment }} disable-maintenance

    - name: Maintenance Summary
      if: success()
      shell: bash
      run: |
        NOW=$(TZ=Europe/London date +"%F %R")
        echo '## 🚧 Maintenance Page ${{ inputs.mode }}d!' >> $GITHUB_STEP_SUMMARY
        echo '' >> $GITHUB_STEP_SUMMARY
        echo '| Field | Value |' >> $GITHUB_STEP_SUMMARY
        echo '|-------|-------|' >> $GITHUB_STEP_SUMMARY
        echo "| **Environment** | ${{ inputs.environment }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Time** | ${NOW} (London) |" >> $GITHUB_STEP_SUMMARY
        if [[ "${{ inputs.mode }}" == "enable" ]]; then
          echo "| **Service** | ${{ inputs.service-name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Message** | ${{ inputs.maintenance-message }} |" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ inputs.estimated-return-time }}" ]]; then
            echo "| **Estimated Return** | ${{ inputs.estimated-return-time }} |" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ -n "${{ inputs.status-page-url }}" ]]; then
            echo "| **Status Page** | [${{ inputs.status-page-url }}](${{ inputs.status-page-url }}) |" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ -n "${{ inputs.contact-email }}" ]]; then
            echo "| **Contact** | ${{ inputs.contact-email }} |" >> $GITHUB_STEP_SUMMARY
          fi
          echo '' >> $GITHUB_STEP_SUMMARY
          
          # Check for temp URLs if available
          if [[ -f ./maintenance_page/manifests/${{ inputs.environment }}/ingress_temp*.yml ]]; then
            echo '### Temporary URLs' >> $GITHUB_STEP_SUMMARY
            TEMP_URLS=$(awk '/name:.*cloud/ {print "- " $2}' ./maintenance_page/manifests/${{ inputs.environment }}/ingress_temp*.yml 2>/dev/null || true)
            if [[ -n "$TEMP_URLS" ]]; then
              echo "$TEMP_URLS" >> $GITHUB_STEP_SUMMARY
            fi
          fi
        fi